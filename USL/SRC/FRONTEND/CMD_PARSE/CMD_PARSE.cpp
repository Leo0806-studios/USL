#include <boost/program_options.hpp>
#include "FRONTEND/CMD_PARSE/CMD_PARSE.h"
import std;
namespace USL::FRONTEND {
	Arguments::Arguments(int argc, char** argv) {

		boost::program_options::options_description desc("allowed options");
		const char* compilerDebugStr = R"(sets variouse debug options to print internal compiler state
possible options:
pt: prints token streams
ptr: prints parse trees
pst: prints symbol tables
pip: prints possible derived types for a baseclass object at that point in the program
pub: prints ub analysis information
pag: prints information related to autogenerated special members
poc: print overload resolution chain information
pOc: print optimisation decisions
tc:  time compilation phases. output is  written to 'compiler_times.json' in the output directory

)";
		desc.add_options()
			("help,h", boost::program_options::bool_switch(), "Display help message")
			("output,o", boost::program_options::value<std::string>(), "Output file")
			("input,i", boost::program_options::value<std::vector<std::string>>(), "Input source files")
			("libPaths,l", boost::program_options::value<std::vector<std::string>>(), "paths to library sources. every libary needs its own folder")
			("optimisationLevel,O", boost::program_options::value<int>()->default_value(0), "set optimisation level (0 to 5). default value: 0")
			("analysisLevel,A", boost::program_options::value<int>()->default_value(3), "set analysis level. controlls extend and kinds of static analysis (0 to 7) default value: 3")
			("warningLeve,W", boost::program_options::value<int>()->default_value(3), "sets the warning level (0-7). default value: 3")
			("warnFail,f", boost::program_options::value<bool>()->default_value(false), "treat warnings as errors. default value: false")
			("enableExceptions,e", boost::program_options::value<bool>()->default_value(true), "enables or disables exceptions. default value: true")
			("compilerDebug,d",boost::program_options::value<std::vector<std::string>>(), compilerDebugStr);
		boost::program_options::variables_map ArgMap;
		boost::program_options::store(boost::program_options::parse_command_line(argc, argv, desc), ArgMap);
		if (ArgMap["help"].as<bool>()) {
			std::cout << desc << '\n'<<std::flush;
			exit(0);
		}
		if (!ArgMap.count("output")) {
			std::cerr << "No output file specified. use -o <output file> to specify an output file" << '\n' << std::flush;
			exit(1);
		}
			outputFile = std::filesystem::path(ArgMap["output"].as<std::string>());
		
		if(ArgMap["input"].empty()){
			std::cerr << "No input files specified. use -i <input files> to specify input files" << '\n' << std::flush;
			exit(1);
		}
		for (const auto& inputFile : ArgMap["input"].as<std::vector<std::string>>()) {
			sourceFiles.emplace_back(inputFile);
		}
		if (!ArgMap["compilerDebug"].empty()) {
			for (const auto& debugOption : ArgMap["compilerDebug"].as<std::vector<std::string>>()) {
				if (debugOption != "pt"  &&
					debugOption != "ptr" && 
					debugOption != "pst" &&
					debugOption != "pip" && 
					debugOption != "pub" && 
					debugOption != "pag" && 
					debugOption != "tc"&&
					debugOption != "poc"&&
					debugOption != "pOc"&&
					debugOption != "pfl"
					) {
					std::cerr << "Invalid compiler debug option: " << debugOption << '\n' << std::flush;
					exit(1);
				}
			}
			const auto& debugOptions = ArgMap["compilerDebug"].as<std::vector<std::string>>();
			for (const auto& debugOption : debugOptions) {
				compilerDebugOptions[debugOption] = true;
			}

		}

	}

	 bool Arguments::IsDebugOptionEnabled(CompilerDebugOptions option) const noexcept {
#pragma warning (push)
#pragma warning (disable: 26447)
		const auto iterator = compilerDebugOptions.find(compilerDebugOptionstranslations.at(option));
#pragma warning (pop)
		if (iterator != compilerDebugOptions.end()) {
			return iterator->second;
		}
		return false;
	}

}// namespace USL::FRONTEND
