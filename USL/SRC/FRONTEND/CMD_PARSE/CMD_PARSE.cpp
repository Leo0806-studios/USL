#if   defined(__clang__)  || defined(__INTELLISENSE__)||defined(TESTS_BUILD)
#include "HEADER/FRONTEND/CMD_PARSE/CMD_PARSE.h"
#include <boost/program_options.hpp>
#include <iostream>
#include <string>
#include <vector>
#else
import <string>;
import <vector>;
import <iostream>;
#include <boost/program_options.hpp>
#include "HEADER/FRONTEND/CMD_PARSE/CMD_PARSE.h"
#endif //  __clang__ || __INTELLISENSE__||defined(TESTS_BUILD)
namespace USL::FRONTEND {
	Arguments::Arguments(int argc, char** argv) {

		boost::program_options::options_description desc("allowed options");
		const char* compilerDebugStr = R"(sets variouse debug options to print internal compiler state
possible options:
Pt: prints token streams
ptr: prints parse trees
pst: prints symbol tables
pip: prints possible derived types for a baseclass object at that point in the program
pub: prints ub analysis information
pag: prints information related to autogenerated special members
poc: print overload resolution chain information
pOc: print optimisation decisions
tc:  time compilation phases. output is  written to 'compiler_times.json' in the output directory

)";
		desc.add_options()
			("help,h", boost::program_options::bool_switch(), "Display help message")
			("output,o", boost::program_options::value<std::string>(), "Output file")
			("input,i", boost::program_options::value<std::vector<std::string>>(), "Input source files")
			("libPaths,l", boost::program_options::value<std::vector<std::string>>(), "paths to library sources. every libary needs its own folder")
			("optimisationLevel,O", boost::program_options::value<int>()->default_value(0), "set optimisation level (0 to 5). default value: 0")
			("analysisLevel,A", boost::program_options::value<int>()->default_value(3), "set analysis level. controlls extend and kinds of static analysis (0 to 7) default value: 3")
			("warningLeve,W", boost::program_options::value<int>()->default_value(3), "sets the warning level (0-7). default value: 3")
			("warnFail,f", boost::program_options::value<bool>()->default_value(false), "treat warnings as errors. default value: false")
			("enableExceptions,e", boost::program_options::value<bool>()->default_value(true), "enables or disables exceptions. default value: true")
			("compilerDebug,cD",boost::program_options::value<std::vector<std::string>>(), compilerDebugStr);
		boost::program_options::variables_map ArgMap;
		boost::program_options::store(boost::program_options::parse_command_line(argc, argv, desc), ArgMap);
		if (ArgMap["help"].as<bool>()) {
			std::cout << desc << std::endl; 
			exit(0);
		}
		if (!ArgMap.count("output")) {
			std::cerr << "No output file specified. use -o <output file> to specify an output file" << std::endl;
			exit(1);
		}
			outputFile = std::filesystem::path(ArgMap["output"].as<std::string>());
		
		if(ArgMap["input"].empty()){
			std::cerr << "No input files specified. use -i <input files> to specify input files" << std::endl;
			exit(1);
		}
		for (const auto& inputFile : ArgMap["input"].as<std::vector<std::string>>()) {
			sourceFiles.emplace_back(inputFile);
		}
		if (!ArgMap["compilerDebug"].empty()) {
			for (const auto& debugOption : ArgMap["compilerDebug"].as<std::vector<std::string>>()) {
				if (debugOption != "Pt"  &&
					debugOption != "ptr" && 
					debugOption != "pst" &&
					debugOption != "pip" && 
					debugOption != "pub" && 
					debugOption != "pag" && 
					debugOption != "tc"&&
					debugOption != "poc"&&
					debugOption != "pOc"
					) {
					std::cerr << "Invalid compiler debug option: " << debugOption << std::endl;
					exit(1);
				}
			}
			const auto& debugOptions = ArgMap["compilerDebug"].as<std::vector<std::string>>();
			for (const auto& debugOption : debugOptions) {
				compilerDebugOptions[debugOption] = true;
			}

		}

	}

}// namespace USL::FRONTEND
